#include "babble-lang.h"
#include "intrinsics.h"

extern intrinsic_info intrinsics [2];

#define GET_INTRINSIC(_ret, _symbol)                        \
{                                                           \
   (*_ret) = NULL;                                          \
    for (int i = 0;                                         \
        i < sizeof (intrinsics) / sizeof (intrinsic_info);  \
        i++) {                                              \
                                                            \
        if (!strcmp (intrinsics[i].symbol, _symbol)) {      \
            (*_ret) = intrinsics[i].source;                 \
            break;                                          \
        }                                                   \
    }                                                       \
}

static void init (FILE *out_file) {
    fprintf (out_file,
        "; ==========================================================\n"
        "; x86-64 Netwide assembly generated by Babble v%d.%d\n"
        "; ==========================================================\n\n",
        BABBLE_VER_MAJOR, BABBLE_VER_MINOR);
    
    // Initialize sections
    fprintf (out_file,
        "section .text\n"
        "global _start\n");
    
    int n_intrinsics = sizeof (intrinsics) / sizeof (intrinsic_info);
    // TODO: Put these in a separate `intrinsics.asm` file and include them in
    for (int i = 0; i < n_intrinsics; i++) {
        if (intrinsics[i].impl) {
            fprintf (out_file, "%s", intrinsics[i].source);
        }
    }
    fprintf (out_file,
        "_quit:\n"
        "mov rdi, 0\n"
        "mov rax, 60\n"
        "syscall\n");
    
    fprintf (out_file, "_start:\n");
}

static int assemble (int debug, const char *asm_name,
    const char *out_name, char *msg) {

    char cmd_buf [MSG_LEN];
    struct timeval ts;
    gettimeofday (&ts, NULL);
    snprintf (cmd_buf, MSG_LEN, "nasm -o %ld.o -f elf64%s %s", ts.tv_usec,
        (debug ? " -gdwarf" : ""), asm_name);
    
    int ret = system (cmd_buf);
    if (ret) {
        snprintf (msg, MSG_LEN, "Babble error: Assembler error "
            "(shell exit code %d). Make sure nasm 2.15+ is installed\n",
            ret);
        return BABBLE_ASSEMBLER_ERR;
    }

    snprintf (cmd_buf, MSG_LEN, "ld%s -o %s %ld.o", (debug ? " -g " : ""),
        out_name, ts.tv_usec);
    ret = system (cmd_buf);
    if (ret) {
        snprintf (msg, MSG_LEN, "Babble error: Linker error (shell exit code %d)\n",
            ret);
        return BABBLE_LINKER_ERR;
    }

    snprintf (cmd_buf, MSG_LEN, "rm -f %ld.o", ts.tv_usec);
    system (cmd_buf);

    return BABBLE_OK;
}

enum block_labels {
    INC,
    EQ,
    REP,
    SCOPE
};

typedef struct block {
    size_t start, end;
    int label;
} block;

typedef struct lexer_blocklist {
    size_t nblocks;
    size_t cap;
    block *blocks;
} blocklist;


static int init_blist (blocklist *blist,
    size_t cap=DEFAULT_NBLOCKS) {
    assert (blocklist != NULL);
    blist->nblocks = 0;
    blist->cap = cap; 
    blist->blocks = (block*) malloc (cap * sizeof (block));
    if (blist->blocks == NULL) {
        return BABBLE_MISC_ERR;
    }
}

static int resize_blist (blocklist *blist) {
    assert (blocks_handle != NULL);
    blist->cap *= 2;
    realloc (blist->blocks, blist->cap);
    if (blist->blocks == NULL) {
        return BABBLE_MISC_ERR;
    }
}

static int push_blist (blocklist *blist,
    size_t start, size_t end, int label) {
    int ret = BABBLE_OK;
    if (blist->nblocks == blist->cap) {
        ret = resize_blocks (blist);
        if (!ret) {
            return ret;
        }
    }
    blist->blocks[blist->cap] = { start, end, label };
    blist->nblocks++;
    return ret;
}

static int free_blist (blocklist *blist) {
    free (blist->blocks);
    memset (blist, 0x0, sizeof (blocklist));
}

static int lex (char *in_buf, size_t buf_size, blocklist *blist) {
    // init_blocks (blocks_handle);
    // Phase 1: Split by ';'
    // Phase 2: Handle REP and SCOPE
    // Phase 3: Label blocks
    
}

int compile (int debug, const char *in_name,
    const char *out_name, char *msg) {

    FILE *in_file = fopen (in_name, "r");
    if (in_file == NULL) {
        snprintf (msg, MSG_LEN, "Babble error: Input file \"%s\" not found\n",
            in_name);
        return BABBLE_FILE_NOT_FOUND;
    }

    char *in_buf;
    size_t in_file_size;

    fseek (in_file, 0L, SEEK_END);
    in_file_size = ftell (in_file);
    rewind (in_file);
    in_buf = (char*) malloc (in_file_size);

    size_t at = 0;
    while (1) {
        char c = fgetc (in_file);
        if (feof (in_file)) {
            break;
        }
        in_buf[at] = c;
    }

    blocklist blist;
    lex (in_buf, &blist);

    struct timeval ts;
    gettimeofday (&ts, NULL);
    char asm_name [MSG_LEN];
    memset (asm_name, 0x0, sizeof (asm_name));
    snprintf (asm_name, MSG_LEN, "%ld.asm", ts.tv_usec);

    char cmd_buf [MSG_LEN];
    snprintf (cmd_buf, MSG_LEN, "rm -f %ld.asm", ts.tv_usec);
    system (cmd_buf);
    snprintf (cmd_buf, MSG_LEN, "touch %ld.asm", ts.tv_usec);
    system (cmd_buf);

    FILE *out_file = fopen (asm_name, "w");
    init (out_file);

    #if 0
    fprintf (out_file,
        "mov rax, 0\n"
        "push rax\n");
    
    char *temp;
    int line = 1;
    int comment = 0;
    while (1) {
        char c = fgetc (in_file);
        if (feof (in_file)) {
            break;
        }
        if (isspace (c) || comment) {
            if (c == '\n' || c == '\r') {
                line++;
                comment = 0;
            }
            continue;
        }
        switch (c) {
            case '+':
                fprintf (out_file,
                    "mov rax, [rsp]\n"
                    "inc rax\n"
                    "mov [rsp], rax\n");
                break;
            case '-':
                fprintf (out_file,
                    "mov rax, [rsp]\n"
                    "dec rax\n"
                    "mov [rsp], rax\n");
                break;
            case 'p':
                {
                    fprintf (out_file, "mov rdi, [rsp]\n");
                    GET_INTRINSIC (&temp, "print_i64");
                    assert (temp != NULL);
                    fprintf (out_file, "%s", temp); 
                }
                break;
            case '%':
                comment = 1;
                break;
            default:
                snprintf (msg, MSG_LEN, "Babble error: Compile error "
                    "on line %d\n", line);
                return BABBLE_COMPILE_ERR;
        }
    }
    fprintf (out_file, "pop rax\n");
    fprintf (out_file, "call _quit\n");
    #endif

    fclose (in_file);
    fclose (out_file);

    int ret = assemble (debug, asm_name, out_name, msg);
    
    snprintf (cmd_buf, MSG_LEN, "rm -f %ld.asm", ts.tv_usec);
    system (cmd_buf);
    return ret;
}