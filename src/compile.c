#include "babble-lang.h"
#include "parse.h"
#include "lex.h"
#include "intrinsics.h"

extern intrinsic_info intrinsics [2];

#define GET_INTRINSIC(_ret, _symbol)                        \
{                                                           \
   (*_ret) = NULL;                                          \
    for (int i = 0;                                         \
        i < sizeof (intrinsics) / sizeof (intrinsic_info);  \
        i++) {                                              \
                                                            \
        if (!strcmp (intrinsics[i].symbol, _symbol)) {      \
            (*_ret) = intrinsics[i].source;                 \
            break;                                          \
        }                                                   \
    }                                                       \
}

static void init (FILE *out_file) {
    fprintf (out_file,
        "; ==========================================================\n"
        "; x86-64 Netwide assembly generated by Babble v%d.%d\n"
        "; ==========================================================\n\n",
        BABBLE_VER_MAJOR, BABBLE_VER_MINOR);
    
    // Initialize sections
    fprintf (out_file,
        "section .text\n"
        "global _start\n");
    
    int n_intrinsics = sizeof (intrinsics) / sizeof (intrinsic_info);
    // TODO: Put these in a separate `intrinsics.asm` file and include them in
    for (int i = 0; i < n_intrinsics; i++) {
        if (intrinsics[i].impl) {
            fprintf (out_file, "%s", intrinsics[i].source);
        }
    }
    fprintf (out_file,
        "_quit:\n"
        "mov rdi, 0\n"
        "mov rax, 60\n"
        "syscall\n");
    
    fprintf (out_file, "_start:\n");
}

static int assemble (int debug, const char *asm_name,
    const char *out_name, char *msg) {

    char cmd_buf [MSG_LEN];
    struct timeval ts;
    gettimeofday (&ts, NULL);
    snprintf (cmd_buf, MSG_LEN, "nasm -o %ld.o -f elf64%s %s", ts.tv_usec,
        (debug ? " -gdwarf" : ""), asm_name);
    
    int ret = system (cmd_buf);
    if (ret) {
        snprintf (msg, MSG_LEN, "Babble error: Assembler error "
            "(shell exit code %d). Make sure nasm 2.15+ is installed\n",
            ret);
        return BABBLE_ASSEMBLER_ERR;
    }

    snprintf (cmd_buf, MSG_LEN, "ld%s -o %s %ld.o", (debug ? " -g " : ""),
        out_name, ts.tv_usec);
    ret = system (cmd_buf);
    if (ret) {
        snprintf (msg, MSG_LEN, "Babble error: Linker error (shell exit code %d)\n",
            ret);
        return BABBLE_LINKER_ERR;
    }

    snprintf (cmd_buf, MSG_LEN, "rm -f %ld.o", ts.tv_usec);
    system (cmd_buf);

    return BABBLE_OK;
}

int compile (int debug, const char *in_name,
    const char *out_name, char *msg) {

    FILE *in_file = fopen (in_name, "r");
    if (in_file == NULL) {
        snprintf (msg, MSG_LEN, "Babble error: Input file \"%s\" not found\n",
            in_name);
        return BABBLE_FILE_NOT_FOUND;
    }
    int ret;
    char *in_buf;
    size_t in_buf_size;

    fseek (in_file, 0L, SEEK_END);
    in_buf_size = ftell (in_file);
    rewind (in_file);
    in_buf = (char*) malloc (in_buf_size);

    size_t at = 0;
    while (1) {
        char c = fgetc (in_file);
        if (feof (in_file)) {
            break;
        }
        in_buf[at] = c;
        at++;
    }

    // Remove comments
    size_t put = 0;
    int comment = 0;
    size_t skipped = 0;
    for (size_t i = 0; i < in_buf_size; i++) {
        if ((in_buf[i] == '\n') || (in_buf[i] == '\r')) {
            comment = 0;
        }
        if (in_buf[i] == '%') {
            comment = 1;
        }
        if (!comment) {
            in_buf[put] = in_buf[i];
            put++;
        } else {
            skipped++;
        }
    }
    in_buf_size -= skipped;

    // Lexical and syntax processing
    blocklist blist;
    ret = lex (in_buf, in_buf_size, &blist, msg);

    if (ret) {
        free_blist (&blist);
        fclose (in_file);
        return ret;
    }

    // Semantic processing and codegen
    #if 0
    Scope open:
        (1). Push symstack w/ rep_id = -1
        2. push rbp, rsp
        3. rbp = rsp + 16
    Scope close:
        (1). If rep_id != -1
            1a. create label .loop_{rep_id}_break
        (3). Pop symstack
        4. rsp = rbp - 16
        5. pop rsp
        6. pop rbp
    Eq:
        (1). Check if left sym exists in scope
        (2). Check if right sym exists in scope, OR is literal
        3. Get lsym location
        4. ...
    Inc:
        Similar to above
    Rep:
        (1). Check if sym exists in scope, OR is literal
        (2) Push symstack w/ rep_id
        2. push rbp, rsp
        3. rbp = rsp + 16
        4. rax = rep amt
        5. create label .loop_{rep_id}
        6. Before loop body:
            6a. cmp rax, 0
            6b. jz .loop_{rep_id}_break
        7. Gen loop body
        8. dec rax
    Print:
        (1). Check if sym exists in scope
        2. Call intrinsic
    
    At end:
        If symstack not at level 0, fail
    Symstack:
        - arr of char**
        - trie of current symbols in scope
            - trie node contains offset from rsp, value
    #endif

    //...
    free_blist (&blist);
    
    struct timeval ts;
    gettimeofday (&ts, NULL);
    char asm_name [MSG_LEN];
    memset (asm_name, 0x0, sizeof (asm_name));
    snprintf (asm_name, MSG_LEN, "%ld.asm", ts.tv_usec);

    char cmd_buf [MSG_LEN];
    snprintf (cmd_buf, MSG_LEN, "rm -f %ld.asm", ts.tv_usec);
    system (cmd_buf);
    snprintf (cmd_buf, MSG_LEN, "touch %ld.asm", ts.tv_usec);
    system (cmd_buf);

    FILE *out_file = fopen (asm_name, "w");
    init (out_file);

    fclose (in_file);
    fclose (out_file);
    #if 0
    ret = assemble (debug, asm_name, out_name, msg);
    #endif
    #ifndef DEBUG
    snprintf (cmd_buf, MSG_LEN, "rm -f %ld.asm", ts.tv_usec);
    system (cmd_buf);
    #endif
    return ret;
}